import {EventEmitter, Injectable} from "@angular/core";
import {Track} from "@data-logic/models/track.model";
import {LoggerService} from "@app-logic/services/logger.service";
import {ProjectService} from "@data-logic/services/project.service";
import {TimesPerProject} from "@data-logic/models/times-per-project.model";

@Injectable({providedIn: 'root'})
export class TrackService {

  begin = new Date();

  trackedTime$ = new EventEmitter<Track>();

  constructor(private projectService: ProjectService) {
    this.initTracking();
  }
  initTracking() {
    //TODO get last tracked time
    // if (this.trackedTimes.length > 0) this.start = this.trackedTimes[this.trackedTimes.length - 1]?.end;
    // this.begin = new Date();
    LoggerService.debug("Init tracking with start:", this.begin);
  }

  getSecondsBetween(start: Date, end: Date) {
    const diff = end.getTime() - start.getTime();

    const seconds = Math.floor(diff / 1000);

    return seconds;
  }

  trackTime(project: string, start: Date | null, end: Date, comment?: string) {
    console.debug("Tracking with", project, start, end, comment);
    this.begin = start ? start : this.begin;
    let track: Track = new Track(
      this.begin,
      end,
      this.getSecondsBetween(this.begin, end),
      project
    );
    track.comment = comment;

    window.electronAPI.trackTime(track).then(
      () => {
        LoggerService.debug("Tracked time", track);
        this.begin = new Date();
        this.trackedTime$.emit(track);
        LoggerService.debug("New tracking begin:", this.begin);
      },
      (error) => {
        window.alert("Fehler beim Tracken " + error.message)
        console.error(error);
      }
    );
  }

  async getWorkedOnDay(day: Date) {
    let dayTrackedTimes = await window.electronAPI.readTrackedTimes(day);
    return this.getWorkedSeconds(dayTrackedTimes);
  }

  async getWorkedSeconds(tracks: Track[]) {
    let projectsToTrack = (await this.projectService.getProjects()).filter(p => p.isTracked).map(p => p.name);
    LoggerService.debug("Projects to track for getting worked seconds", projectsToTrack);
    let workedSeconds = 0;
    if (tracks) {
      workedSeconds = tracks.reduce((acc, track) => {
        if (projectsToTrack.includes(track.project)) {
          acc += track.workedSeconds;
        }
        return acc;
      }, workedSeconds);
    } else {
      return this.getWorkedTimeString(0);
    }
    return this.getWorkedTimeString(workedSeconds);
  }

  getWorkedTimeString(workedSeconds: number) {
    return `${Math.floor(workedSeconds / 3600).toString().padStart(2, '0')}:${Math.floor(workedSeconds / 60 % 60).toString().padStart(2, '0')}:${(workedSeconds % 60).toString().padStart(2, '0')}`; //TODO check this (generated by gpt)
  }

  async getWorkedInProjectsOnDay(day: Date) {
    let dayTrackedTimes = await window.electronAPI.readTrackedTimes(day);
    console.debug("Got tracked times for", day, dayTrackedTimes);
    let workedPerProject = new Map<string, {worked: number, comments: string}>();
    if (dayTrackedTimes) {
      dayTrackedTimes.forEach(track => {
        if (workedPerProject.has(track.project)) {
          workedPerProject.get(track.project)!.worked += track.workedSeconds;
          workedPerProject.get(track.project)!.comments += track.comment ? track.comment + "; " : "";
        } else {
          workedPerProject.set(track.project, {worked: track.workedSeconds, comments: track.comment ? track.comment + "; " : ""});
        }
      });
    }

    let timesPerProject: TimesPerProject[] = [];
    for (let [project, data] of workedPerProject) {
      timesPerProject.push(new TimesPerProject(project, data.worked, data.comments));
    }

    return timesPerProject;
  }
}
