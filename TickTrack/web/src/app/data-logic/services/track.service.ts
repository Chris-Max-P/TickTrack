import {EventEmitter, Injectable} from "@angular/core";
import {Track} from "@data-logic/models/track.model";
import {LoggerService} from "@app-logic/services/logger.service";
import {ProjectService} from "@data-logic/services/project.service";

@Injectable({providedIn: 'root'})
export class TrackService {

  begin = new Date();

  trackedTime$ = new EventEmitter<Track>();

  constructor(private projectService: ProjectService) {
    this.initTracking();
  }
  initTracking() {
    //TODO get last tracked time
    // if (this.trackedTimes.length > 0) this.start = this.trackedTimes[this.trackedTimes.length - 1]?.end;
    // this.begin = new Date();
    LoggerService.debug("Init tracking with start:", this.begin);
  }

  getSecondsBetween(start: Date, end: Date) {
    const diff = end.getTime() - start.getTime();

    const seconds = Math.floor(diff / 1000);

    return seconds;
  }

  trackTime(project: string, end: Date, comment?: string) {
    let track: Track = new Track(
      this.begin,
      end,
      this.getSecondsBetween(this.begin, end),
      project
    );
    track.comment = comment;

    window.electronAPI.trackTime(track).then(
      () => {
        LoggerService.debug("Tracked time", track);
        this.trackedTime$.emit(track);
        this.begin = end;
        LoggerService.debug("New tracking begin:", this.begin);
      },
      (error) => {
        window.alert("Fehler beim Tracken " + error.message)
        console.error(error);
      }
    );
  }

  async getWorkedOnDay(day: Date) {
    let dayTrackedTimes = await window.electronAPI.readTrackedTimes(day);
    let workedSeconds = 0;
    let projectsToTrack = (await this.projectService.getProjects()).filter(p => p.isTracked).map(p => p.name);
    console.log(projectsToTrack)
    if (dayTrackedTimes) {
      workedSeconds = dayTrackedTimes.reduce((acc, track) => {
        if (projectsToTrack.includes(track.project)) {
          acc += track.workedSeconds;
        }
        return acc;
      }, workedSeconds);
    } else {
      return "00:00:00";
    }
    return this.getWorkedTimeString(workedSeconds);
  }

  getWorkedTimeString(workedSeconds: number) {
    return `${Math.floor(workedSeconds / 3600)}:${Math.floor(workedSeconds / 60 % 60).toString().padStart(2, '0')}:${(workedSeconds % 60).toString().padStart(2, '0')}`; //TODO check this (generated by gpt)
  }

  async getWorkedInProjectsOnDay(day: Date) {
    let dayTrackedTimes = await window.electronAPI.readTrackedTimes(day);
    let workedPerProject = new Map<string, {worked: number, comments: string}>();
    if (dayTrackedTimes) {
      dayTrackedTimes.forEach(track => {
        if (workedPerProject.has(track.project)) {
          workedPerProject.get(track.project)!.worked += track.workedSeconds;
          workedPerProject.get(track.project)!.comments += track.comment ? track.comment + "; " : "";
        } else {
          workedPerProject.set(track.project, {worked: track.workedSeconds, comments: track.comment ? track.comment + "; " : ""});
        }
      });
    }
    return workedPerProject;
  }
}
